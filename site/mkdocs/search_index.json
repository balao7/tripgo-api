{
    "docs": [
        {
            "location": "/",
            "text": "TripGo API\n\n\nThe TripGo API allows you to plan \ndoor-to-door trips\n using a large variety of \npublic and private transport.\n It integrates \nreal-time\n information and, for selected providers, allows users to \nbook and pay\n for transport.\n\n\n\n\nGetting started\n\n\nGetting an API key\n\n\nThe API is not yet open to the public. If you would like early access, \nplease email us\n. For details about pricing and on limits of the free tier, see the \nSkedGo website\n.\n\n\nOnce you have an API key, make sure to send it along with every request as the \nX-TripGo-Key\n header.\n\n\nBefore you dive in\n\n\nThis API is powered by multiple servers, not all of which cover every region. \nYou have to use the correct host names for the region that you query\n. You get those host names by first querying \nregions.json\n and looking up the \nurls\n for that region. You should only cache this information short term as those URLs can change without notice.\n\n\nThis API is optimised to return a large number of trip results while maintaining a small package sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates.\n\n\n\n\nAPI specs\n\n\nThe specifications are available in OpenAPI (formerly Swagger) format. Pick your favorite UI to browse the specs:\n\n\n\n\nSwagger UI\n\n\nSwagger editor UI\n\n\n\n\n\n\nAdvanced\n\n\nOnce you dig into the API, you'll likely soon want to know more about some of its details.\n\n\nGeneral:\n\n\n\n\nRegions and base URLs\n\n\nMode identifiers explained\n\n\nConstructing URLs for images (coming soon)\n\n\n\n\nRouting:\n\n\n\n\nSingle-modal vs. multi-modal routing\n\n\nTrips, groups, frequencies and templates\n\n\nPlaceholders in segment templates (coming soon)\n\n\n\n\nLocations:\n\n\n\n\nLocations, cell IDs and hash codes\n\n\n\n\n\n\nDeep Linking\n\n\nFor a light-weight alternative to using our API, you can also deep-link into the TripGo app.\n\n\nRouting results\n\n\n$schema://$host/go?$parameters\n\n\nOpens the routing results for the specified destination, and optionally the start and time:\n\n\n\n\nflat\n, \nflng\n: Start coordinates. If not specified, the user's current location is used.\n\n\ntlat\n, \ntlng\n: End coordinates. Required, unless \ntname\n is provided.\n\n\ntname\n: Destination as a search string (supports \nwhat3words\n). Required, unless \ntlat\n and \ntlng\n are provided.\n\n\ntype\n: \n0\n for leaving ASAP, \n1\n for leaving after \ntime\n, \n2\n for arriving by \ntime\n. Required.\n\n\ntime\n: Query time in seconds since 1970. Required, unless \ntype\n is set to \n0\n.\n\n\n\n\nExamples:\n\n\n\n\niOS: \ntripgo:///go?tname=dragon.letter.spoke\n\n\nWeb: \nhttp://tripgo.me/go?tname=dragon.letter.spoke\n\n\n\n\nDestination information\n\n\n$schema://$host/meet?$parameters\n\n\nOpens the search screen with the destination and arrival time filled in.\n\n\n\n\nlat\n, \nlng\n: Coordinate where to meet. Required, unless \nname\n is provided.\n\n\nname\n: Destination as a search string (supports \nwhat3words\n). Required, unless \nlat\n and \nlng\n are provided.\n\n\ntime\n: Arrival time in seconds since 1970. Required.\n\n\n\n\nExamples:\n\n\n\n\niOS: \ntripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734\n\n\nWeb: \nhttp://tripgo.me/meet?lat=-33.94501&lng=151.25807&at=1385535734\n\n\n\n\nTimetable\n\n\n$schema://$host/stop/$region/$stopCode\n\n\nOpens the departures timetable for a given stop. \n$region\n and \n$stop\n use region codes and stop codes as defined in our API.\n\n\nExamples:\n\n\n\n\niOS: \ntripgo:///stop/AU_NSW_Sydney/2035143\n\n\nWeb: \nhttp://tripgo.me/stop/AU_NSW_Sydney/2035143\n\n\n\n\n\n\nTransport Provider Integration\n\n\nFor integrating new transport services into the TripGo app, as well as the TripGo API, please have a look at our \nTransport Providers website\n and get in touch with our team.",
            "title": "Home"
        },
        {
            "location": "/#tripgo-api",
            "text": "The TripGo API allows you to plan  door-to-door trips  using a large variety of  public and private transport.  It integrates  real-time  information and, for selected providers, allows users to  book and pay  for transport.",
            "title": "TripGo API"
        },
        {
            "location": "/#getting-started",
            "text": "",
            "title": "Getting started"
        },
        {
            "location": "/#getting-an-api-key",
            "text": "The API is not yet open to the public. If you would like early access,  please email us . For details about pricing and on limits of the free tier, see the  SkedGo website .  Once you have an API key, make sure to send it along with every request as the  X-TripGo-Key  header.",
            "title": "Getting an API key"
        },
        {
            "location": "/#before-you-dive-in",
            "text": "This API is powered by multiple servers, not all of which cover every region.  You have to use the correct host names for the region that you query . You get those host names by first querying  regions.json  and looking up the  urls  for that region. You should only cache this information short term as those URLs can change without notice.  This API is optimised to return a large number of trip results while maintaining a small package sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates.",
            "title": "Before you dive in"
        },
        {
            "location": "/#api-specs",
            "text": "The specifications are available in OpenAPI (formerly Swagger) format. Pick your favorite UI to browse the specs:   Swagger UI  Swagger editor UI",
            "title": "API specs"
        },
        {
            "location": "/#advanced",
            "text": "Once you dig into the API, you'll likely soon want to know more about some of its details.  General:   Regions and base URLs  Mode identifiers explained  Constructing URLs for images (coming soon)   Routing:   Single-modal vs. multi-modal routing  Trips, groups, frequencies and templates  Placeholders in segment templates (coming soon)   Locations:   Locations, cell IDs and hash codes",
            "title": "Advanced"
        },
        {
            "location": "/#deep-linking",
            "text": "For a light-weight alternative to using our API, you can also deep-link into the TripGo app.",
            "title": "Deep Linking"
        },
        {
            "location": "/#routing-results",
            "text": "$schema://$host/go?$parameters  Opens the routing results for the specified destination, and optionally the start and time:   flat ,  flng : Start coordinates. If not specified, the user's current location is used.  tlat ,  tlng : End coordinates. Required, unless  tname  is provided.  tname : Destination as a search string (supports  what3words ). Required, unless  tlat  and  tlng  are provided.  type :  0  for leaving ASAP,  1  for leaving after  time ,  2  for arriving by  time . Required.  time : Query time in seconds since 1970. Required, unless  type  is set to  0 .   Examples:   iOS:  tripgo:///go?tname=dragon.letter.spoke  Web:  http://tripgo.me/go?tname=dragon.letter.spoke",
            "title": "Routing results"
        },
        {
            "location": "/#destination-information",
            "text": "$schema://$host/meet?$parameters  Opens the search screen with the destination and arrival time filled in.   lat ,  lng : Coordinate where to meet. Required, unless  name  is provided.  name : Destination as a search string (supports  what3words ). Required, unless  lat  and  lng  are provided.  time : Arrival time in seconds since 1970. Required.   Examples:   iOS:  tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734  Web:  http://tripgo.me/meet?lat=-33.94501&lng=151.25807&at=1385535734",
            "title": "Destination information"
        },
        {
            "location": "/#timetable",
            "text": "$schema://$host/stop/$region/$stopCode  Opens the departures timetable for a given stop.  $region  and  $stop  use region codes and stop codes as defined in our API.  Examples:   iOS:  tripgo:///stop/AU_NSW_Sydney/2035143  Web:  http://tripgo.me/stop/AU_NSW_Sydney/2035143",
            "title": "Timetable"
        },
        {
            "location": "/#transport-provider-integration",
            "text": "For integrating new transport services into the TripGo app, as well as the TripGo API, please have a look at our  Transport Providers website  and get in touch with our team.",
            "title": "Transport Provider Integration"
        },
        {
            "location": "/advanced/",
            "text": "General\n\n\nRegions and base URLs\n\n\n\n\nWhat is the base URL of the API? What, wait... why does it depend on the region?\n\n\n\n\nThe way the TripGo API currently works, the base URL for everything except the \nregions.json\n endpoint depends on the region: \n\n\n\n\nHit \nhttps://tripgo.skedgo.com/satapp/regions.json\n\n\nFind the region you\u2019re interested in, e.g., \nUK_London\n\n\nThen use a URL from that regions \nurls\n as the base URL for all subsequent calls: e.g., \nhttps://hadron-uk-london.tripgo.skedgo.com/satapp/routing.json\n\n\n\n\nThe reason for this is that we have a few servers around the globe, but not every server has every region, and if there\u2019s an error connecting to one server, the clients can switch to the next. (If you want to be fancy, you could also ping each server and directly send requests to the server that's responding the fastest.)\n\n\nWe are currently considering to do that work server-side to make the API easier to use by just having a single base URL for all calls for all regions.\n\n\n\n\nMode Identifiers\n\n\n\n\nWhat are all these peculiar looking strings such as \npt_pub\n?\n\n\n\n\nSyntax\n\n\nThe syntax of the mode string is like this:\n\n\n<group>_<mode that makes sense to the user>[_<provider or fine-grained mode>]\n\n\nList of groups\n\n\n\n\npt_\n is for transit which runs on schedules\n\n\nps_\n is for taxi-like on-demand services\n\n\nme_\n is for vehicles you drive yourself\n\n\ncy_\n is for cycling\n\n\nwa_\n is for walking\n\n\nin_\n is for intercity long distance transport\n\n\n\n\npt_\n\n\n\n\npt_pub\n is \"public transit\" that is accessible to public\n\n\npt_pub_bus\n\n\npt_pub_train\n\n\npt_pub_ferry\n\n\npt_pub_tram\n\n\npt_pub_subway\n\n\npt_pub_monorail\n\n\npt_pub_cablecar\n\n\npt_pub_funicular\n\n\npt_pub_gondola\n\n\npt_ltd_SCHOOLBUS\n is public transit of limited access (school buses)\n\n\n\n\nps_\n\n\n\n\nps_tax\n is for taxis\n\n\nps_tnc\n is for uber and alike (TNC is California's official code for them)\n\n\nps_tnc_lyft\n\n\nps_tnc_sidecar\n\n\nps_tnc_uber\n\n\nps_shu\n is for (airport) shuttles\n\n\n\n\nme_\n\n\n\n\nme_car\n is for your own car\n\n\nme_car-s\n is for car sharing (like ZipCar or GoGet)\n\n\nme_car-r\n is for car rental (like Budget)\n\n\nme_car-p\n is for car pooling (like BlaBlaCar)\n\n\nme_mot\n is for your own motorbike\n\n\n\n\n\n\nRouting\n\n\nSingle-modal vs. multi-modal routing\n\n\n\n\nHow do I get these sweet results which combine taxis or other private transport modes with public transport?\n\n\n\n\nYou need to specify multiple modes in the \nrouting.json\n requests, e.g., by using \nmodes=pt_pub&modes=ps_tax\n. You can specify a long list of modes as the API will then return suitable combinations for any of those.\n\n\n\n\nWhat if I want to get both public-transport-only results and mixed results?\n\n\n\n\nIn this case you need to currently send off two requests: Say, one with \nmodes=pt_pub\n and one with \nmodes=pt_pub&modes=ps_tax\n.\n\n\nWe've done it this way as the mixed-modal can be a fair bit slower as the routing engine has more combinations too crunch and, typically, also depends on more external API calls, which slows things down further.\n\n\nRequests that specify more than one mode will only return results which use at least two of the specified modes. That way you don't need to do duplicate detection between the single-modal and mixed-modal results.\n\n\n\n\nTrips, groups, frequencies and templates\n\n\n\n\nWhat is the logic behind trip groups and what does the frequency property mean?\n\n\n\n\nEach group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.\n\n\nFrequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.\n\n\nIn our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest \nweightedScore\n.\n\n\n\n\nWhy are segments split into references and templates?\n\n\n\n\nThis is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.\n\n\n\n\nLocations\n\n\nLocations, cell IDs and hash codes\n\n\n\n\nWhat are the cell IDs in the \nlocations.json\n endpoint?\n\n\n\n\nThe way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as \n$(lat*cellsPerDegree)#$(lng*cellsPerDegree)\n.\n\n\n\n\nGot it. And \ncellIDHashCodes\n?\n\n\n\n\nYou typically call \nlocations.json\n with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use \ncellIDHashCodes\n as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.\n\n\n\n\nExample\n\n\nLet's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}\n\n\n\nYou'll then get results:\n\n\n{\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}\n\n\n\nYou can then cache these and later on request again for changes by supplying \ncellIDHashCodes\n:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}\n\n\n\nWhich will then only return any groups that have changed. If nothing changed, you'll just get back:\n\n\n{\n  \"groups\": []\n}\n\n\n\n\n\nNote\n: You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}",
            "title": "Advanced"
        },
        {
            "location": "/advanced/#general",
            "text": "",
            "title": "General"
        },
        {
            "location": "/advanced/#regions-and-base-urls",
            "text": "What is the base URL of the API? What, wait... why does it depend on the region?   The way the TripGo API currently works, the base URL for everything except the  regions.json  endpoint depends on the region:    Hit  https://tripgo.skedgo.com/satapp/regions.json  Find the region you\u2019re interested in, e.g.,  UK_London  Then use a URL from that regions  urls  as the base URL for all subsequent calls: e.g.,  https://hadron-uk-london.tripgo.skedgo.com/satapp/routing.json   The reason for this is that we have a few servers around the globe, but not every server has every region, and if there\u2019s an error connecting to one server, the clients can switch to the next. (If you want to be fancy, you could also ping each server and directly send requests to the server that's responding the fastest.)  We are currently considering to do that work server-side to make the API easier to use by just having a single base URL for all calls for all regions.",
            "title": "Regions and base URLs"
        },
        {
            "location": "/advanced/#mode-identifiers",
            "text": "What are all these peculiar looking strings such as  pt_pub ?",
            "title": "Mode Identifiers"
        },
        {
            "location": "/advanced/#syntax",
            "text": "The syntax of the mode string is like this:  <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>]",
            "title": "Syntax"
        },
        {
            "location": "/advanced/#list-of-groups",
            "text": "pt_  is for transit which runs on schedules  ps_  is for taxi-like on-demand services  me_  is for vehicles you drive yourself  cy_  is for cycling  wa_  is for walking  in_  is for intercity long distance transport",
            "title": "List of groups"
        },
        {
            "location": "/advanced/#pt_",
            "text": "pt_pub  is \"public transit\" that is accessible to public  pt_pub_bus  pt_pub_train  pt_pub_ferry  pt_pub_tram  pt_pub_subway  pt_pub_monorail  pt_pub_cablecar  pt_pub_funicular  pt_pub_gondola  pt_ltd_SCHOOLBUS  is public transit of limited access (school buses)",
            "title": "pt_"
        },
        {
            "location": "/advanced/#ps_",
            "text": "ps_tax  is for taxis  ps_tnc  is for uber and alike (TNC is California's official code for them)  ps_tnc_lyft  ps_tnc_sidecar  ps_tnc_uber  ps_shu  is for (airport) shuttles",
            "title": "ps_"
        },
        {
            "location": "/advanced/#me_",
            "text": "me_car  is for your own car  me_car-s  is for car sharing (like ZipCar or GoGet)  me_car-r  is for car rental (like Budget)  me_car-p  is for car pooling (like BlaBlaCar)  me_mot  is for your own motorbike",
            "title": "me_"
        },
        {
            "location": "/advanced/#routing",
            "text": "",
            "title": "Routing"
        },
        {
            "location": "/advanced/#single-modal-vs-multi-modal-routing",
            "text": "How do I get these sweet results which combine taxis or other private transport modes with public transport?   You need to specify multiple modes in the  routing.json  requests, e.g., by using  modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those.   What if I want to get both public-transport-only results and mixed results?   In this case you need to currently send off two requests: Say, one with  modes=pt_pub  and one with  modes=pt_pub&modes=ps_tax .  We've done it this way as the mixed-modal can be a fair bit slower as the routing engine has more combinations too crunch and, typically, also depends on more external API calls, which slows things down further.  Requests that specify more than one mode will only return results which use at least two of the specified modes. That way you don't need to do duplicate detection between the single-modal and mixed-modal results.",
            "title": "Single-modal vs. multi-modal routing"
        },
        {
            "location": "/advanced/#trips-groups-frequencies-and-templates",
            "text": "What is the logic behind trip groups and what does the frequency property mean?   Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.  Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.  In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest  weightedScore .   Why are segments split into references and templates?   This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.",
            "title": "Trips, groups, frequencies and templates"
        },
        {
            "location": "/advanced/#locations",
            "text": "",
            "title": "Locations"
        },
        {
            "location": "/advanced/#locations-cell-ids-and-hash-codes",
            "text": "What are the cell IDs in the  locations.json  endpoint?   The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as  $(lat*cellsPerDegree)#$(lng*cellsPerDegree) .   Got it. And  cellIDHashCodes ?   You typically call  locations.json  with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use  cellIDHashCodes  as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.",
            "title": "Locations, cell IDs and hash codes"
        },
        {
            "location": "/advanced/#example",
            "text": "Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}  You'll then get results:  {\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}  You can then cache these and later on request again for changes by supplying  cellIDHashCodes :  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}  Which will then only return any groups that have changed. If nothing changed, you'll just get back:  {\n  \"groups\": []\n}   Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}",
            "title": "Example"
        },
        {
            "location": "/bookings/overview/",
            "text": "Overview\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nThe TripGo API allows making bookings for a handful of transport service providers (TSPs).\n\n\nThis enables your users to:\n\n\n\n\nLink their TSP accounts and keep credentials either stored on the client or server-side.\n\n\nGet a list of available TSP products for a trip.\n\n\nBook a specific TSP product for a single segment.\n\n\nUpdate the trip with the details of the booked TSP product.\n\n\nUpdate the trip with real-time data specific to that booking.\n\n\n\n\nComing soon:\n\n\n\n\nBook a complete trip consisting of multiple products from multiple TSPs.\n\n\n\n\nIn order to enable bookings for your TripGo API key, please \nget in touch with our team\n. For most TSPs, you will need to provide us with additional information of your API credentials.\n\n\n\n\nAPI Endpoints\n\n\nLinking and unlinking accounts\n\n\nBefore you can do any bookings, you will need to provide the relevant authentication details to the server.\n\n\nIf the user has an account (as per the \nuserToken\n header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.\n\n\n\n\nauth/{region}?mode={mode}\n: Endpoint to get the available providers for a specific region, with the information to signin/logout if a \nuserToken\n is provided in the headers. If \nmode\n is provided, only information for that mode is returned.\n\n\nauth/{provider}/signin\n: Endpoint to link an account for the specified provider.\n\n\nauth/{provider}/logout\n: Endpoint to unlink an account for the specified provider.\n\n\n\n\nAuth Flow\n\n\nThis flow will depend on the TSP and can be started in two separate ways:\n\n\n\n\nWhen \nlinking accounts\n to a user.\n\n\nWhen doing a \nbooking\n for that particular TSP and the user has no account already linked.\n\n\n\n\nThis flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.\n\n\nFor a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including \nclientId\n, \nclientSecret\n, \nscope\n, \nauthUrl\n, \ntokenUrl\n; and also the required field to be POSTed, including \naccessToken\n, \nrefreshToken\n and \nexpiration\n.\n\n\nFor a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for \nForm-based Booking Flow\n.\n\n\nThe end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of \nForm-based Booking Flow\n.\n\n\n\n\nGetting available TSP for a trip\n\n\nIf there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.\n\n\nThe booking object in the segment may include:\n\n\n\n\na \nquickBookingUrl\n, indicating that the quick booking flow is available.\n\n\na \nbookingUrl\n, indicating that the form-based booking flow is available.\n\n\n\n\n\n\nBooking a segment\n\n\nTo book a segment, either use the \nForm-based Booking Flow\n with the \nbookingURL\n either directly from the segment reference, or the \nQuick Booking Flow\n from the data returned after hitting \nquickBookingUrl\n.\n\n\nForm-based Booking Flow\n\n\nIf form-based booking flow is available for a segment, the \nbookingUrl\n will return a \nBooking Form\n object with instructions to start the booking flow.\n\nA form-based booking flow will possible include the following steps:\n\n\n1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start \nAuth flow\n,\n4) attempt to do the booking and return the Status Form.\n\n\nQuick Booking Flow\n\n\nGetting available TSP products for a trip\n\n\nIf quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. \n\n\nAs part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:\n\n\n\n\ntripUpdateURL\n: A URL for fetching the trip, updated for this TSP product.\n\n\nbookingURL\n: A URL for initiating the booking flow for this TSP product (step 2 of \nform-based booking flow\n)\n\n\ntitle\n\n\nsubtitle\n\n\nbookingTitle\n\n\npriceString\n\n\nprice\n\n\nUSDPrice\n\n\nsurgeString\n\n\nsurgeImageURL\n\n\nETA\n\n\nimageURL\n\n\n\n\n\n\nUpdating trip with booking details\n\n\nAt the end of the booking flow, you will get a \nrefreshURLForSourceObject\n. Hit this URL with a GET request, to get the updated trip.\n\n\nNote that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.\n\n\n\n\nBooking Form Specs\n\n\nBoth the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.\n\n\nThere exists three different forms:\n\n\n\n\nBooking Form\n\n\nAuth Form\n\n\nStatus Form\n\n\n\n\nAll three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.\n\n\nA Booking Form may include:\n\n\n\n\na title\n\n\na subtitle\n\n\na value\n\n\na \nBookingAction\n, which may include:\n\n\na \nURL\n, to go to the next step in the flow\n\n\na \ntitle\n\n\na \nhudText\n, with a human readable string describing the action (meant to be shown while waiting the response from the backend)\n\n\na boolean \nfinalStep\n, meaning that the next step is the one that will actually do the booking.\n\n\na boolean \ndone\n, indicating that there are no more steps in the flow.\n\n\n\n\n\n\na list of \nFormGroups\n.\n\n\n\n\nA \nFormGroup\n is a lisf of \nFormFields\n with a title and an optional footer.\nA \nFormField\n is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:\n\n\n\n\na (unique) \nid\n, to identify the field\n\n\na \ntitle\n\n\na \nsubtitle\n\n\na \nsidetitle\n\n\na \nvalue\n, that will depend on the FormField type\n\n\na boolean \nrequired\n, indicating that this is a required field to be POSTed,\n\n\na boolean \nreadOnly\n, indicating that this is information to be shown to the user but can not be edited.\n\n\na boolean \nhidden\n, indicating that this field should NOT be shown to the user.\n\n\n\n\nThere are several types of FormFields:\n\n\n\n\nstring\n, which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}\n\n\ntext\n, for long non-editable strings\n\n\nswitch\n, for boolean values\n\n\noption\n, for a list of values, will include the list and the default value\n\n\naddress\n, for locations, value with the following format {lat, lng, address, name}\n\n\ndatetime\n, including the time value in long and an extra field with the timezone id \n\n\nstepper\n, for int values, with extra max and min values\n\n\ntime\n, for seconds since midnight\n\n\npassword\n\n\nlink\n, for urls, with an extra field called \nmethod\n with the following possible values:\n\n\nrefresh\n meaning that this url will return the same step form,\n\n\npost\n meaning that the backend expects a POST on that url,\n\n\n\n\nexternal\n meaning that this will go to an external site, so, no BookingForm will be returned.\n\n\n\n\n\n\nbookingForm\n, this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.\n\n\n\n\n\n\n\n\nBookings in the TripKit SDKs\n\n\nThe TripKit SDKs implement support for bookings:\n\n\n\n\nBookings in TripKit Android\n\n\nBookings in TripKit iOS",
            "title": "Overview"
        },
        {
            "location": "/bookings/overview/#overview",
            "text": "Note: Enterprise customers-only  Note: Beta-only  The TripGo API allows making bookings for a handful of transport service providers (TSPs).  This enables your users to:   Link their TSP accounts and keep credentials either stored on the client or server-side.  Get a list of available TSP products for a trip.  Book a specific TSP product for a single segment.  Update the trip with the details of the booked TSP product.  Update the trip with real-time data specific to that booking.   Coming soon:   Book a complete trip consisting of multiple products from multiple TSPs.   In order to enable bookings for your TripGo API key, please  get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.",
            "title": "Overview"
        },
        {
            "location": "/bookings/overview/#api-endpoints",
            "text": "",
            "title": "API Endpoints"
        },
        {
            "location": "/bookings/overview/#linking-and-unlinking-accounts",
            "text": "Before you can do any bookings, you will need to provide the relevant authentication details to the server.  If the user has an account (as per the  userToken  header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.   auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a  userToken  is provided in the headers. If  mode  is provided, only information for that mode is returned.  auth/{provider}/signin : Endpoint to link an account for the specified provider.  auth/{provider}/logout : Endpoint to unlink an account for the specified provider.",
            "title": "Linking and unlinking accounts"
        },
        {
            "location": "/bookings/overview/#auth-flow",
            "text": "This flow will depend on the TSP and can be started in two separate ways:   When  linking accounts  to a user.  When doing a  booking  for that particular TSP and the user has no account already linked.   This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.  For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including  clientId ,  clientSecret ,  scope ,  authUrl ,  tokenUrl ; and also the required field to be POSTed, including  accessToken ,  refreshToken  and  expiration .  For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for  Form-based Booking Flow .  The end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of  Form-based Booking Flow .",
            "title": "Auth Flow"
        },
        {
            "location": "/bookings/overview/#getting-available-tsp-for-a-trip",
            "text": "If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.  The booking object in the segment may include:   a  quickBookingUrl , indicating that the quick booking flow is available.  a  bookingUrl , indicating that the form-based booking flow is available.",
            "title": "Getting available TSP for a trip"
        },
        {
            "location": "/bookings/overview/#booking-a-segment",
            "text": "To book a segment, either use the  Form-based Booking Flow  with the  bookingURL  either directly from the segment reference, or the  Quick Booking Flow  from the data returned after hitting  quickBookingUrl .",
            "title": "Booking a segment"
        },
        {
            "location": "/bookings/overview/#form-based-booking-flow",
            "text": "If form-based booking flow is available for a segment, the  bookingUrl  will return a  Booking Form  object with instructions to start the booking flow. \nA form-based booking flow will possible include the following steps:  1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start  Auth flow ,\n4) attempt to do the booking and return the Status Form.",
            "title": "Form-based Booking Flow"
        },
        {
            "location": "/bookings/overview/#quick-booking-flow",
            "text": "Getting available TSP products for a trip  If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details.   As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:   tripUpdateURL : A URL for fetching the trip, updated for this TSP product.  bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of  form-based booking flow )  title  subtitle  bookingTitle  priceString  price  USDPrice  surgeString  surgeImageURL  ETA  imageURL",
            "title": "Quick Booking Flow"
        },
        {
            "location": "/bookings/overview/#updating-trip-with-booking-details",
            "text": "At the end of the booking flow, you will get a  refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip.  Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.",
            "title": "Updating trip with booking details"
        },
        {
            "location": "/bookings/overview/#booking-form-specs",
            "text": "Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.  There exists three different forms:   Booking Form  Auth Form  Status Form   All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.  A Booking Form may include:   a title  a subtitle  a value  a  BookingAction , which may include:  a  URL , to go to the next step in the flow  a  title  a  hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend)  a boolean  finalStep , meaning that the next step is the one that will actually do the booking.  a boolean  done , indicating that there are no more steps in the flow.    a list of  FormGroups .   A  FormGroup  is a lisf of  FormFields  with a title and an optional footer.\nA  FormField  is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:   a (unique)  id , to identify the field  a  title  a  subtitle  a  sidetitle  a  value , that will depend on the FormField type  a boolean  required , indicating that this is a required field to be POSTed,  a boolean  readOnly , indicating that this is information to be shown to the user but can not be edited.  a boolean  hidden , indicating that this field should NOT be shown to the user.   There are several types of FormFields:   string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}  text , for long non-editable strings  switch , for boolean values  option , for a list of values, will include the list and the default value  address , for locations, value with the following format {lat, lng, address, name}  datetime , including the time value in long and an extra field with the timezone id   stepper , for int values, with extra max and min values  time , for seconds since midnight  password  link , for urls, with an extra field called  method  with the following possible values:  refresh  meaning that this url will return the same step form,  post  meaning that the backend expects a POST on that url,   external  meaning that this will go to an external site, so, no BookingForm will be returned.    bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.",
            "title": "Booking Form Specs"
        },
        {
            "location": "/bookings/overview/#bookings-in-the-tripkit-sdks",
            "text": "The TripKit SDKs implement support for bookings:   Bookings in TripKit Android  Bookings in TripKit iOS",
            "title": "Bookings in the TripKit SDKs"
        },
        {
            "location": "/bookings/android/",
            "text": "Bookings in TripKit Android\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\n\n\nLinking and unlinking accounts\n\n\n// TODO\n\n\n\n\nGetting available TSP products for a trip\n\n\n// TODO\n\n\n\n\nBooking a segment\n\n\n// TODO\n\n\n\n\nUpdating trip with booking details\n\n\n// TODO",
            "title": "Android SDK"
        },
        {
            "location": "/bookings/android/#bookings-in-tripkit-android",
            "text": "Note: Enterprise customers-only  Note: Beta-only",
            "title": "Bookings in TripKit Android"
        },
        {
            "location": "/bookings/android/#linking-and-unlinking-accounts",
            "text": "// TODO",
            "title": "Linking and unlinking accounts"
        },
        {
            "location": "/bookings/android/#getting-available-tsp-products-for-a-trip",
            "text": "// TODO",
            "title": "Getting available TSP products for a trip"
        },
        {
            "location": "/bookings/android/#booking-a-segment",
            "text": "// TODO",
            "title": "Booking a segment"
        },
        {
            "location": "/bookings/android/#updating-trip-with-booking-details",
            "text": "// TODO",
            "title": "Updating trip with booking details"
        },
        {
            "location": "/bookings/ios/",
            "text": "Bookings in TripKit iOS\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nTripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.\n\n\nPreparations\n\n\nTo get started, configured your project as follows:\n\n\n\n\nInclude \nBookingKit\n from \nshared-ios\n, including all its dependencies.\n\n\nInclude \ntripkit-ios\n as a dependency, including its \nBookings\n add-on.\n\n\nAdd the \nOAuthCallbackURL\n to your \nConfig.plist\n configuration file.\n\n\nMake sure your app has the URL scheme from that callback URL registered.\n\n\n\n\nNext, you need to respond to calls to that \nOAuthCallbackURL\n in your application delegate by implementing \napplication(openURL:options)\n (or its deprecated precursors), and handling the calls similar to this:\n\n\nlet OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}\n\n\n\n\n\n\nLinking and unlinking accounts\n\n\nYou can then which accounts are available for linking for a given region:\n\n\nlet region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}\n\n\n\n\nThis both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account, \nand\n they have not expired.\n\n\nTo kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on \nRxSwift\n:\n\n\nregion.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n\n\n\n\nNote that this helper requires the \nactionURL\n as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified \nmode\n:\n\n\nThese credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the \nregion.linkedAccounts()\n helper above.\n\n\nFor unlinking an account again there's another helper:\n\n\nregion.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}\n\n\n\n\nNote that the helper for unlinking, only requires the \nactionURL\n when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.\n\n\n\n\nGetting available TSP products for a trip\n\n\nAvailable TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.\n\n\nWhether such TSP products are available, is indicated by the segment having a \nbookingQuickInternalURL\n. If that URL exists, the \nTKQuickBookingHelper\n can then fetch all the available products:\n\n\nTKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}\n\n\n\n\nNote\n: Fetching this information does typically not require the user to have linked their account with the TSP of that segment.\n\n\nEach of these come with a variety of information about the product, possibly including information on the price or ETA.\n\n\nThe two main actions that you can take with these details are:\n\n\n\n\nUpdate the trip with the product, using the \ntripUpdateURL\n (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.\n\n\nBook the product, the using \nbookingURL\n (see below for details).\n\n\n\n\n\n\nBooking a segment\n\n\nUsers can book trip on a segment-by-segment basis. The booking requires the \nbookingURL\n for the specific product that the user wants to book as mentioned in the previous section.\n\n\nTripKit iOS has a helper method \nBPKOperator.makeBookingToURL/2\n which then initiates the booking:\n\n\nlet mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}\n\n\n\n\nThis method does a handful of things:\n\n\n\n\nIt checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the \nmode\n parameter).\n\n\nIf the user's account has not been linked, the \nBPKOperator\n will start the OAuth process described \nin the section on linking accounts\n.\n\n\nIf the user's account has already been linked, those credentials will be used.\n\n\nIf there's an error during this process, then observable aborts with an error.\n\n\n\n\n\n\nAn attempt to make the booking is performed, which can have the following outcomes:\n\n\nThe booking was successful and \nBookingResult.UpdateTrip\n is returned with a URL to update the trip, which will then include the confirmation details.\n\n\nThe booking can be made, but more information is required by the user. This is the case \nBookingResult.LoadTrip\n which returns a booking form, which can be then be displayed using the \nBPKBookingViewController\n.\n\n\nThe booking can be made, but the user first need to accept an agreement. This is the case \n`BookingResult.UpdateTrip\n which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to \nBPKOperator.makeBookingToURL\n again.\n\n\nIf there's an error, the observable aborts with an error.\n\n\n\n\n\n\n\n\n\n\nUpdating trip with booking details / confirmation\n\n\nAs described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.\n\n\nThis process is the same as updating a trip with real-time data, e.g.:\n\n\nlet router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}\n\n\n\n\nNoteworthy is here, the \nsegment.bookingConfirmation\n property provided by \nTKQuickBookingHelper\n which returns a \nTKBookingConfirmation\n struct after a booking has been made. This struct includes:\n\n\n\n\nstatus\n: A title and optional description describing the current status of the trip.\n\n\nInformation on the \nprovider\n and \nvehicle\n servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.\n\n\nA list of actions, such as calling the provider or cancelling the booking.",
            "title": "iOS SDK"
        },
        {
            "location": "/bookings/ios/#bookings-in-tripkit-ios",
            "text": "Note: Enterprise customers-only  Note: Beta-only  TripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.",
            "title": "Bookings in TripKit iOS"
        },
        {
            "location": "/bookings/ios/#preparations",
            "text": "To get started, configured your project as follows:   Include  BookingKit  from  shared-ios , including all its dependencies.  Include  tripkit-ios  as a dependency, including its  Bookings  add-on.  Add the  OAuthCallbackURL  to your  Config.plist  configuration file.  Make sure your app has the URL scheme from that callback URL registered.   Next, you need to respond to calls to that  OAuthCallbackURL  in your application delegate by implementing  application(openURL:options)  (or its deprecated precursors), and handling the calls similar to this:  let OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}",
            "title": "Preparations"
        },
        {
            "location": "/bookings/ios/#linking-and-unlinking-accounts",
            "text": "You can then which accounts are available for linking for a given region:  let region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}  This both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account,  and  they have not expired.  To kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on  RxSwift :  region.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)  Note that this helper requires the  actionURL  as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified  mode :  These credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the  region.linkedAccounts()  helper above.  For unlinking an account again there's another helper:  region.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}  Note that the helper for unlinking, only requires the  actionURL  when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.",
            "title": "Linking and unlinking accounts"
        },
        {
            "location": "/bookings/ios/#getting-available-tsp-products-for-a-trip",
            "text": "Available TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.  Whether such TSP products are available, is indicated by the segment having a  bookingQuickInternalURL . If that URL exists, the  TKQuickBookingHelper  can then fetch all the available products:  TKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}  Note : Fetching this information does typically not require the user to have linked their account with the TSP of that segment.  Each of these come with a variety of information about the product, possibly including information on the price or ETA.  The two main actions that you can take with these details are:   Update the trip with the product, using the  tripUpdateURL  (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.  Book the product, the using  bookingURL  (see below for details).",
            "title": "Getting available TSP products for a trip"
        },
        {
            "location": "/bookings/ios/#booking-a-segment",
            "text": "Users can book trip on a segment-by-segment basis. The booking requires the  bookingURL  for the specific product that the user wants to book as mentioned in the previous section.  TripKit iOS has a helper method  BPKOperator.makeBookingToURL/2  which then initiates the booking:  let mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}  This method does a handful of things:   It checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the  mode  parameter).  If the user's account has not been linked, the  BPKOperator  will start the OAuth process described  in the section on linking accounts .  If the user's account has already been linked, those credentials will be used.  If there's an error during this process, then observable aborts with an error.    An attempt to make the booking is performed, which can have the following outcomes:  The booking was successful and  BookingResult.UpdateTrip  is returned with a URL to update the trip, which will then include the confirmation details.  The booking can be made, but more information is required by the user. This is the case  BookingResult.LoadTrip  which returns a booking form, which can be then be displayed using the  BPKBookingViewController .  The booking can be made, but the user first need to accept an agreement. This is the case  `BookingResult.UpdateTrip  which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to  BPKOperator.makeBookingToURL  again.  If there's an error, the observable aborts with an error.",
            "title": "Booking a segment"
        },
        {
            "location": "/bookings/ios/#updating-trip-with-booking-details-confirmation",
            "text": "As described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.  This process is the same as updating a trip with real-time data, e.g.:  let router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}  Noteworthy is here, the  segment.bookingConfirmation  property provided by  TKQuickBookingHelper  which returns a  TKBookingConfirmation  struct after a booking has been made. This struct includes:   status : A title and optional description describing the current status of the trip.  Information on the  provider  and  vehicle  servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.  A list of actions, such as calling the provider or cancelling the booking.",
            "title": "Updating trip with booking details / confirmation"
        }
    ]
}