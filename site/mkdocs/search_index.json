{
    "docs": [
        {
            "location": "/",
            "text": "TripGo API\n\n\nThe TripGo API allows you to plan \ndoor-to-door trips\n using a large variety of \npublic and private transport.\n It integrates \nreal-time\n information and, for selected providers, allows users to \nbook and pay\n for transport.\n\n\n\n\nGetting started\n\n\n1. Getting an API key\n\n\nGet an API key\n. You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the \nSkedGo website\n.\n\n\nOnce you have an API key, send it along with every request as the \nX-TripGo-Key\n header.\n\n\n2. Getting the base URL\n\n\nUnfortunately we don't yet have a unified URL for all areas, as failover is expected to be done client-side.  You can get a list of regions and URLs with something like:\n\n\ncurl 'https://tripgo.skedgo.com/satapp/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}'\n\n\n\n\nKeep in mind that this API is powered by multiple servers, not all of which cover every region. \nYou have to use the correct host names for the region that you query\n. You get those host names by first querying \nregions.json\n and looking up the \nurls\n for that region. You should only cache this information short term as those URLs can change without notice.\n\n\n3. Make a request\n\n\nOur API can do a lot more than just \ndirections\n, but if that is what you are interested in, then try something like:\n\n\ncurl 'https://granduni-au-nsw-sydney-tripgo.skedgo.com/satapp/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g\n\n\n\n\nor \n\n\ncurl 'https://granduni-au-nsw-sydney-tripgo.skedgo.com/satapp/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g\n\n\n\n\nKeep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further \nin the F.A.Q.\n.\n\n\n4. Where to go from here?\n\n\n\n\n\n\nIf you're an app developer, take a look at our open source TripKit \nSDKs for \niOS, macOS\n and \nAndroid\n.\n\n\n\n\n\n\nIf you're a web developer, take a look at \nour \nsample app\n \"FastGo\"\n and its accompanying \nblog post series\n.\n\n\n\n\n\n\nIf you're a backend developer, dive into the \nAPI specs\n, which are available in OpenAPI (formerly Swagger) format.\n\n\n\n\n\n\nContinue reading with our \nin-depth \nguides\n.\n\n\n\n\n\n\nIf you know how to debug a web app, look at the network activity for \nour web app\n to get an idea of which API calls to use when.  (Filter for \"satapp\".)\n\n\n\n\n\n\nTo talk to us and other developers using our API, join our Slack team.",
            "title": "Getting Started"
        },
        {
            "location": "/#tripgo-api",
            "text": "The TripGo API allows you to plan  door-to-door trips  using a large variety of  public and private transport.  It integrates  real-time  information and, for selected providers, allows users to  book and pay  for transport.",
            "title": "TripGo API"
        },
        {
            "location": "/#getting-started",
            "text": "",
            "title": "Getting started"
        },
        {
            "location": "/#1-getting-an-api-key",
            "text": "Get an API key . You can try it out for free for as long as you like, as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the  SkedGo website .  Once you have an API key, send it along with every request as the  X-TripGo-Key  header.",
            "title": "1. Getting an API key"
        },
        {
            "location": "/#2-getting-the-base-url",
            "text": "Unfortunately we don't yet have a unified URL for all areas, as failover is expected to be done client-side.  You can get a list of regions and URLs with something like:  curl 'https://tripgo.skedgo.com/satapp/regions.json' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}'  Keep in mind that this API is powered by multiple servers, not all of which cover every region.  You have to use the correct host names for the region that you query . You get those host names by first querying  regions.json  and looking up the  urls  for that region. You should only cache this information short term as those URLs can change without notice.",
            "title": "2. Getting the base URL"
        },
        {
            "location": "/#3-make-a-request",
            "text": "Our API can do a lot more than just  directions , but if that is what you are interested in, then try something like:  curl 'https://granduni-au-nsw-sydney-tripgo.skedgo.com/satapp/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes[]=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g  or   curl 'https://granduni-au-nsw-sydney-tripgo.skedgo.com/satapp/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes[]=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g  Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further  in the F.A.Q. .",
            "title": "3. Make a request"
        },
        {
            "location": "/#4-where-to-go-from-here",
            "text": "If you're an app developer, take a look at our open source TripKit  SDKs for  iOS, macOS  and  Android .    If you're a web developer, take a look at  our  sample app  \"FastGo\"  and its accompanying  blog post series .    If you're a backend developer, dive into the  API specs , which are available in OpenAPI (formerly Swagger) format.    Continue reading with our  in-depth  guides .    If you know how to debug a web app, look at the network activity for  our web app  to get an idea of which API calls to use when.  (Filter for \"satapp\".)    To talk to us and other developers using our API, join our Slack team.",
            "title": "4. Where to go from here?"
        },
        {
            "location": "/faq/",
            "text": "General\n\n\nBase URLs and regions\n\n\n\n\nWhat is the base URL of the API? What, wait... why does it depend on the region?\n\n\n\n\nThe way the TripGo API currently works, the base URL for everything except the \nregions.json\n endpoint depends on the region: \n\n\n\n\nHit \nhttps://tripgo.skedgo.com/satapp/regions.json\n\n\nFind the region you\u2019re interested in, e.g., \nUK_London\n\n\nThen use a URL from that regions \nurls\n as the base URL for all subsequent calls: e.g., \nhttps://hadron-uk-london.tripgo.skedgo.com/satapp/routing.json\n\n\n\n\nThe reason for this is that we have a few servers around the globe, but not every server has every region, and if there\u2019s an error connecting to one server, the clients can switch to the next. (If you want to be fancy, you could also ping each server and directly send requests to the server that's responding the fastest.)\n\n\nWe are currently considering to do that work server-side to make the API easier to use by just having a single base URL for all calls for all regions.\n\n\n\n\nLanguages\n\n\n\n\nWhich languages does the API support?\n\n\n\n\nMost text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish.\n\n\nThe translations are done \nin the open on Crowdin\n and everyone can contribute, including adding new languages.\n\n\nOne note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.\n\n\n\n\nRouting\n\n\nMode Identifiers\n\n\n\n\nWhat are all these peculiar looking strings such as \npt_pub\n?\n\n\n\n\nSyntax\n\n\nThe syntax of the mode string is like this:\n\n\n<group>_<mode that makes sense to the user>[_<provider or fine-grained mode>]\n\n\nList of groups\n\n\n\n\npt_\n is for transit which runs on schedules\n\n\nps_\n is for taxi-like on-demand services\n\n\nme_\n is for vehicles you drive yourself\n\n\ncy_\n is for cycling\n\n\nwa_\n is for walking\n\n\nin_\n is for intercity long distance transport\n\n\n\n\npt_\n\n\n\n\npt_pub\n is \"public transit\" that is accessible to public\n\n\npt_pub_bus\n\n\npt_pub_train\n\n\npt_pub_ferry\n\n\npt_pub_tram\n\n\npt_pub_subway\n\n\npt_pub_monorail\n\n\npt_pub_cablecar\n\n\npt_pub_funicular\n\n\npt_pub_gondola\n\n\npt_ltd_SCHOOLBUS\n is public transit of limited access (school buses)\n\n\n\n\nps_\n\n\n\n\nps_tax\n is for taxis\n\n\nps_tnc\n is for uber and alike (TNC is California's official code for them)\n\n\nps_tnc_lyft\n\n\nps_tnc_sidecar\n\n\nps_tnc_uber\n\n\nps_shu\n is for (airport) shuttles\n\n\n\n\nme_\n\n\n\n\nme_car\n is for your own car\n\n\nme_car-s\n is for car sharing (like ZipCar or GoGet)\n\n\nme_car-r\n is for car rental (like Budget)\n\n\nme_car-p\n is for car pooling (like BlaBlaCar)\n\n\nme_mot\n is for your own motorbike\n\n\n\n\n\n\nSingle-modal vs. multi-modal routing\n\n\n\n\nHow do I get these sweet results which combine taxis or other private transport modes with public transport?\n\n\n\n\nYou need to specify multiple modes in the \nrouting.json\n requests, e.g., by using \nmodes=pt_pub&modes=ps_tax\n. You can specify a long list of modes as the API will then return suitable combinations for any of those.\n\n\n\n\nWhat if I want to get both public-transport-only results and mixed results?\n\n\n\n\nIn this case you need to currently send off two requests: Say, one with \nmodes=pt_pub\n and one with \nmodes=pt_pub&modes=ps_tax\n.\n\n\nWe've done it this way as the mixed-modal can be a fair bit slower as the routing engine has more combinations too crunch and, typically, also depends on more external API calls, which slows things down further.\n\n\nRequests that specify more than one mode will only return results which use at least two of the specified modes. That way you don't need to do duplicate detection between the single-modal and mixed-modal results.\n\n\n\n\nTrips, groups, frequencies and templates\n\n\n\n\nWhat is the logic behind trip groups and what does the frequency property mean?\n\n\n\n\nEach group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.\n\n\nFrequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.\n\n\nIn our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest \nweightedScore\n.\n\n\n\n\nWhy are segments split into references and templates?\n\n\n\n\nThis is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.\n\n\n\n\nPlaceholders in segment templates\n\n\n\n\nWhat are all the possible values for placeholders and how should they get interpreted?\n\n\n\n\nIn order to use segment templates for multiple similar segments, the \nnotes\n and \naction\n fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data.\n\n\n\n\n<NUMBER>\n: Placeholder for the number of short name of the transit service, e.g., \nsegment.serviceNumber\n.\n\n\n<LINE_NAME>\n: Placeholder for the long name of the transit service, e.g., \nsegment.serviceName\n.\n\n\n<DIRECTION>\n: Placeholder for the direction of the transit service, e.g., \nsegment.serviceDirection\n.\n\n\n<LOCATIONS>\n: Placeholder for the start and end location of the segment, e.g., \nsegment.start -> segment.end\n.\n\n\n<PLATFORM>\n: Placeholder for the embarkation platform of the transit service, e.g., \nsegment.platform\n.\n\n\n<STOPS>\n: Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., \nsegment.stops\n.\n\n\n<TIME>\n*: Placeholder for the departure time of the segment, e.g., \nsegment.startTime\n formatted as a time. Note that this can directly follow a \n<NUMBER>\n template, so you might have to add spacing. \n\n\n<DURATION>\n*: Placeholder for the total duration of the segment, e.g., \nsegment.endTime - segment.startTime\n formatted as a duration string.\n\n\n<TRAFFIC>\n: (Badly named) placeholder for the total duration \nwithout\n traffic of the segment, e.g., \nsegment.durationWithoutTraffic\n formatted as a duration string.\n\n\n\n\n*\n: Should be updated with real-time data.\n\n\n\n\nLocations\n\n\nLocations, cell IDs and hash codes\n\n\n\n\nWhat are the cell IDs in the \nlocations.json\n endpoint?\n\n\n\n\nThe way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as \n$(lat*cellsPerDegree)#$(lng*cellsPerDegree)\n.\n\n\n\n\nGot it. And \ncellIDHashCodes\n?\n\n\n\n\nYou typically call \nlocations.json\n with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use \ncellIDHashCodes\n as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.\n\n\n\n\nExample\n\n\nLet's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}\n\n\n\nYou'll then get results:\n\n\n{\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}\n\n\n\nYou can then cache these and later on request again for changes by supplying \ncellIDHashCodes\n:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}\n\n\n\nWhich will then only return any groups that have changed. If nothing changed, you'll just get back:\n\n\n{\n  \"groups\": []\n}\n\n\n\n\n\nNote\n: You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:\n\n\n{\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}",
            "title": "F.A.Q."
        },
        {
            "location": "/faq/#general",
            "text": "",
            "title": "General"
        },
        {
            "location": "/faq/#base-urls-and-regions",
            "text": "What is the base URL of the API? What, wait... why does it depend on the region?   The way the TripGo API currently works, the base URL for everything except the  regions.json  endpoint depends on the region:    Hit  https://tripgo.skedgo.com/satapp/regions.json  Find the region you\u2019re interested in, e.g.,  UK_London  Then use a URL from that regions  urls  as the base URL for all subsequent calls: e.g.,  https://hadron-uk-london.tripgo.skedgo.com/satapp/routing.json   The reason for this is that we have a few servers around the globe, but not every server has every region, and if there\u2019s an error connecting to one server, the clients can switch to the next. (If you want to be fancy, you could also ping each server and directly send requests to the server that's responding the fastest.)  We are currently considering to do that work server-side to make the API easier to use by just having a single base URL for all calls for all regions.",
            "title": "Base URLs and regions"
        },
        {
            "location": "/faq/#languages",
            "text": "Which languages does the API support?   Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish.  The translations are done  in the open on Crowdin  and everyone can contribute, including adding new languages.  One note of causion: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.",
            "title": "Languages"
        },
        {
            "location": "/faq/#routing",
            "text": "",
            "title": "Routing"
        },
        {
            "location": "/faq/#mode-identifiers",
            "text": "What are all these peculiar looking strings such as  pt_pub ?",
            "title": "Mode Identifiers"
        },
        {
            "location": "/faq/#syntax",
            "text": "The syntax of the mode string is like this:  <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>]",
            "title": "Syntax"
        },
        {
            "location": "/faq/#list-of-groups",
            "text": "pt_  is for transit which runs on schedules  ps_  is for taxi-like on-demand services  me_  is for vehicles you drive yourself  cy_  is for cycling  wa_  is for walking  in_  is for intercity long distance transport",
            "title": "List of groups"
        },
        {
            "location": "/faq/#pt_",
            "text": "pt_pub  is \"public transit\" that is accessible to public  pt_pub_bus  pt_pub_train  pt_pub_ferry  pt_pub_tram  pt_pub_subway  pt_pub_monorail  pt_pub_cablecar  pt_pub_funicular  pt_pub_gondola  pt_ltd_SCHOOLBUS  is public transit of limited access (school buses)",
            "title": "pt_"
        },
        {
            "location": "/faq/#ps_",
            "text": "ps_tax  is for taxis  ps_tnc  is for uber and alike (TNC is California's official code for them)  ps_tnc_lyft  ps_tnc_sidecar  ps_tnc_uber  ps_shu  is for (airport) shuttles",
            "title": "ps_"
        },
        {
            "location": "/faq/#me_",
            "text": "me_car  is for your own car  me_car-s  is for car sharing (like ZipCar or GoGet)  me_car-r  is for car rental (like Budget)  me_car-p  is for car pooling (like BlaBlaCar)  me_mot  is for your own motorbike",
            "title": "me_"
        },
        {
            "location": "/faq/#single-modal-vs-multi-modal-routing",
            "text": "How do I get these sweet results which combine taxis or other private transport modes with public transport?   You need to specify multiple modes in the  routing.json  requests, e.g., by using  modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those.   What if I want to get both public-transport-only results and mixed results?   In this case you need to currently send off two requests: Say, one with  modes=pt_pub  and one with  modes=pt_pub&modes=ps_tax .  We've done it this way as the mixed-modal can be a fair bit slower as the routing engine has more combinations too crunch and, typically, also depends on more external API calls, which slows things down further.  Requests that specify more than one mode will only return results which use at least two of the specified modes. That way you don't need to do duplicate detection between the single-modal and mixed-modal results.",
            "title": "Single-modal vs. multi-modal routing"
        },
        {
            "location": "/faq/#trips-groups-frequencies-and-templates",
            "text": "What is the logic behind trip groups and what does the frequency property mean?   Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times.  Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group.  In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest  weightedScore .   Why are segments split into references and templates?   This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.",
            "title": "Trips, groups, frequencies and templates"
        },
        {
            "location": "/faq/#placeholders-in-segment-templates",
            "text": "What are all the possible values for placeholders and how should they get interpreted?   In order to use segment templates for multiple similar segments, the  notes  and  action  fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data.   <NUMBER> : Placeholder for the number of short name of the transit service, e.g.,  segment.serviceNumber .  <LINE_NAME> : Placeholder for the long name of the transit service, e.g.,  segment.serviceName .  <DIRECTION> : Placeholder for the direction of the transit service, e.g.,  segment.serviceDirection .  <LOCATIONS> : Placeholder for the start and end location of the segment, e.g.,  segment.start -> segment.end .  <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g.,  segment.platform .  <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g.,  segment.stops .  <TIME> *: Placeholder for the departure time of the segment, e.g.,  segment.startTime  formatted as a time. Note that this can directly follow a  <NUMBER>  template, so you might have to add spacing.   <DURATION> *: Placeholder for the total duration of the segment, e.g.,  segment.endTime - segment.startTime  formatted as a duration string.  <TRAFFIC> : (Badly named) placeholder for the total duration  without  traffic of the segment, e.g.,  segment.durationWithoutTraffic  formatted as a duration string.   * : Should be updated with real-time data.",
            "title": "Placeholders in segment templates"
        },
        {
            "location": "/faq/#locations",
            "text": "",
            "title": "Locations"
        },
        {
            "location": "/faq/#locations-cell-ids-and-hash-codes",
            "text": "What are the cell IDs in the  locations.json  endpoint?   The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as  $(lat*cellsPerDegree)#$(lng*cellsPerDegree) .   Got it. And  cellIDHashCodes ?   You typically call  locations.json  with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use  cellIDHashCodes  as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.",
            "title": "Locations, cell IDs and hash codes"
        },
        {
            "location": "/faq/#example",
            "text": "Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDs\": [\n    \"-2540#11339\",\n    \"-2540#11340\",\n    \"-2540#11341\",\n    \"-2541#11339\",\n    \"-2541#11340\",\n    \"-2541#11341\",\n    \"-2542#11339\",\n    \"-2542#11340\",\n    \"-2542#11341\"\n  ]\n}  You'll then get results:  {\n  \"groups\": [\n    {\n      \"hashCode\": 690784261,\n      \"key\": \"-2540#11339\",\n      \"stops\": [...]\n    },\n    {\n      \"hashCode\": -1940969928,\n      \"key\": \"-2540#11340\",\n      \"stops\": [...]\n    }\n  ]\n}  You can then cache these and later on request again for changes by supplying  cellIDHashCodes :  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"level\": 2,\n  \"cellIDHashCodes\": {\n    \"-2540#11339\": 690784261,\n    \"-2540#11340\": -1940969928\n  }\n}  Which will then only return any groups that have changed. If nothing changed, you'll just get back:  {\n  \"groups\": []\n}   Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself:  {\n  \"region\": \"AU_NSW_Sydney\",\n  \"cellIDHashCodes\": {\n    \"AU_NSW_Sydney\": 1096794422\n  }\n}",
            "title": "Example"
        },
        {
            "location": "/extensions/",
            "text": "Extensions\n\n\nRight after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system.\n\n\nThe TripGo API can be extended in the following ways:\n\n\n\n\nAdd transport modes (or regions) that require API keys, such as Uber, Lyft or certain public transport providers that require you to sign up with them first.\n\n\nAdd new transport modes through our TSP Connectors (coming soon).\n\n\nAdd new regions through our Region Connectors (coming soon).\n\n\n\n\n\n\nAdding transport modes\n\n\nTo get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team \nby mail\n or on Slack.\n\n\nCar2go \ud83c\udf0f\n\n\nIntegrations\n: Locations, Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of the car2go API\n and make sure you comply with them in your app.\n\n\nMail openapi@car2go.com\n as described in there.\n\n\nOnce you've received the car2go \"consumer key\" and \"shared secret\" for your app, \nforward those to us\n. We'll then link your TripGo API key to those and car2go results will start coming through the TripGo API for your API key.\n\n\n\n\nFlitWays \ud83c\uddfa\ud83c\uddf8\n\n\nIntegrations\n: Routing, Real-time\n\n\n\n\nGet in touch with FlitWays and get access to \ntheir API\n.\n\n\nForward us\n your FlitWays API key. We'll then link it to your TripGo API key and FlitWays results will start coming through the TripGo API for your API key.\n\n\n\n\nMyDriver \ud83c\udf0e\n\n\nIntegrations\n: Routing, Real-time\n\n\n\n\nGet in touch with \nMyDriver\n's sales team and get access to their API.\n\n\nForward us\n your MyDriver API key. We'll then link it to your TripGo API key and MyDriver results will start coming through the TripGo API for your API key.\n\n\n\n\nLyft \ud83c\uddfa\ud83c\uddf8\n\n\nIntegrations\n: Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of Lyft's API\n and make sure you comply with them in your app.\n\n\nSign up to \nLyft's API\n.\n\n\nForward us\n your Lyft client ID and client secret. We'll then link it to your TripGo API key and Lyft results will start coming through the TripGo API for your API key.\n\n\n\n\nUber \ud83c\udf0e\n\n\nIntegrations\n: Routing, Real-time, Bookings\n\n\n\n\nRead the \nterms of use of Uber's API\n and make sure you comply with them in your app.\n\n\nSign up to \nUber's ride request API\n.\n\n\nForward us\n your Uber client ID, client secret and server token. We'll then link it to your TripGo API key and Uber results will start coming through the TripGo API for your API key.\n\n\n\n\nZipcar \ud83c\uddfa\ud83c\uddf8\n\n\nIntegrations\n: Locations, Routing, Real-time\n\n\n\n\nGet in touch with \nZipcar\n and get access to their API.\n\n\nForward us\n your Zipcar API key. We'll then link it to your TripGo API key and Zipcar results will start coming through the TripGo API for your API key.\n\n\n\n\n\n\nAdding regions\n\n\nTo get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team \nby mail\n or on Slack.",
            "title": "Extensions"
        },
        {
            "location": "/extensions/#extensions",
            "text": "Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system.  The TripGo API can be extended in the following ways:   Add transport modes (or regions) that require API keys, such as Uber, Lyft or certain public transport providers that require you to sign up with them first.  Add new transport modes through our TSP Connectors (coming soon).  Add new regions through our Region Connectors (coming soon).",
            "title": "Extensions"
        },
        {
            "location": "/extensions/#adding-transport-modes",
            "text": "To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team  by mail  or on Slack.",
            "title": "Adding transport modes"
        },
        {
            "location": "/extensions/#car2go",
            "text": "Integrations : Locations, Routing, Real-time, Bookings   Read the  terms of use of the car2go API  and make sure you comply with them in your app.  Mail openapi@car2go.com  as described in there.  Once you've received the car2go \"consumer key\" and \"shared secret\" for your app,  forward those to us . We'll then link your TripGo API key to those and car2go results will start coming through the TripGo API for your API key.",
            "title": "Car2go \ud83c\udf0f"
        },
        {
            "location": "/extensions/#flitways",
            "text": "Integrations : Routing, Real-time   Get in touch with FlitWays and get access to  their API .  Forward us  your FlitWays API key. We'll then link it to your TripGo API key and FlitWays results will start coming through the TripGo API for your API key.",
            "title": "FlitWays \ud83c\uddfa\ud83c\uddf8"
        },
        {
            "location": "/extensions/#mydriver",
            "text": "Integrations : Routing, Real-time   Get in touch with  MyDriver 's sales team and get access to their API.  Forward us  your MyDriver API key. We'll then link it to your TripGo API key and MyDriver results will start coming through the TripGo API for your API key.",
            "title": "MyDriver \ud83c\udf0e"
        },
        {
            "location": "/extensions/#lyft",
            "text": "Integrations : Routing, Real-time, Bookings   Read the  terms of use of Lyft's API  and make sure you comply with them in your app.  Sign up to  Lyft's API .  Forward us  your Lyft client ID and client secret. We'll then link it to your TripGo API key and Lyft results will start coming through the TripGo API for your API key.",
            "title": "Lyft \ud83c\uddfa\ud83c\uddf8"
        },
        {
            "location": "/extensions/#uber",
            "text": "Integrations : Routing, Real-time, Bookings   Read the  terms of use of Uber's API  and make sure you comply with them in your app.  Sign up to  Uber's ride request API .  Forward us  your Uber client ID, client secret and server token. We'll then link it to your TripGo API key and Uber results will start coming through the TripGo API for your API key.",
            "title": "Uber \ud83c\udf0e"
        },
        {
            "location": "/extensions/#zipcar",
            "text": "Integrations : Locations, Routing, Real-time   Get in touch with  Zipcar  and get access to their API.  Forward us  your Zipcar API key. We'll then link it to your TripGo API key and Zipcar results will start coming through the TripGo API for your API key.",
            "title": "Zipcar \ud83c\uddfa\ud83c\uddf8"
        },
        {
            "location": "/extensions/#adding-regions",
            "text": "To get results for regions with providers that aren't using Open Data, or which we haven't yet been connected to our system, please get in touch with our team  by mail  or on Slack.",
            "title": "Adding regions"
        },
        {
            "location": "/enterprise/push/",
            "text": "Push Notifications\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nWe support Push Notifications for both Android (using \nFirebase\n) and iOS (using \nAPN\n) devices. In order to enable and use Push Notifications, the following steps are required:\n\n\n\n\nRegister (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details).\n\n\nEach app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using \n/api/user/push\n endpoint.\n\n\nTo send PN to your user, you need to know the user ID on our database and use \n/api/push\n endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted). \n\n\n\n\nAndroid\n\n\nYou need to create your own project in \nFirebase\n and send to us the \nServer Key\n in your \nproject settings > cloud messaging\n tab.\n\n\nFor instructions on how to implement Push Notifications in Android, go to \nFirebase Cloud Messaging\n.\n\n\nIn short, your app needs to register into FCM to get a token and save it into our database for later usage (see \n/user/push\n endpoint). Note that this token may change, any time that happens you need to save it again in the database.\n\n\niOS\n\n\nYou need to configure your app for APN, follow instructions \nhere\n and send us the \nApple Push Notification Authentication Key\n and its password.\n\n\nFor instructions on how to implement Push Notifications in iOS, go to \nConfiguring Remote Notification\n.\n\n\nIn short, your app needs to register into APN to get a token and save it into our database for later usage (see \n/api/user/push\n endpoint). Note that this token may change, any time that happens you need to save it again in the database.\n\n\nSending PN\n\n\nIf you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use \n/api/push\n endpoint to send notifications to a list of users (by their userID).\n\n\nCurrently, we only support a simple notification that includes a message, a sound and a badge, with a ttl (time to live) value. If you need other kinds of notifications, please contact us.",
            "title": "Push Notifications"
        },
        {
            "location": "/enterprise/push/#push-notifications",
            "text": "Note: Enterprise customers-only  Note: Beta-only  We support Push Notifications for both Android (using  Firebase ) and iOS (using  APN ) devices. In order to enable and use Push Notifications, the following steps are required:   Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details).  Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using  /api/user/push  endpoint.  To send PN to your user, you need to know the user ID on our database and use  /api/push  endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted).",
            "title": "Push Notifications"
        },
        {
            "location": "/enterprise/push/#android",
            "text": "You need to create your own project in  Firebase  and send to us the  Server Key  in your  project settings > cloud messaging  tab.  For instructions on how to implement Push Notifications in Android, go to  Firebase Cloud Messaging .  In short, your app needs to register into FCM to get a token and save it into our database for later usage (see  /user/push  endpoint). Note that this token may change, any time that happens you need to save it again in the database.",
            "title": "Android"
        },
        {
            "location": "/enterprise/push/#ios",
            "text": "You need to configure your app for APN, follow instructions  here  and send us the  Apple Push Notification Authentication Key  and its password.  For instructions on how to implement Push Notifications in iOS, go to  Configuring Remote Notification .  In short, your app needs to register into APN to get a token and save it into our database for later usage (see  /api/user/push  endpoint). Note that this token may change, any time that happens you need to save it again in the database.",
            "title": "iOS"
        },
        {
            "location": "/enterprise/push/#sending-pn",
            "text": "If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use  /api/push  endpoint to send notifications to a list of users (by their userID).  Currently, we only support a simple notification that includes a message, a sound and a badge, with a ttl (time to live) value. If you need other kinds of notifications, please contact us.",
            "title": "Sending PN"
        },
        {
            "location": "/enterprise/bookings-api/",
            "text": "Overview\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nThe TripGo API allows making bookings for a handful of transport service providers (TSPs).\n\n\nThis enables your users to:\n\n\n\n\nLink their TSP accounts and keep credentials either stored on the client or server-side.\n\n\nGet a list of available TSP products for a trip.\n\n\nBook a specific TSP product for a single segment.\n\n\nUpdate the trip with the details of the booked TSP product.\n\n\nUpdate the trip with real-time data specific to that booking.\n\n\n\n\nComing soon:\n\n\n\n\nBook a complete trip consisting of multiple products from multiple TSPs.\n\n\n\n\nIn order to enable bookings for your TripGo API key, please \nget in touch with our team\n. For most TSPs, you will need to provide us with additional information of your API credentials.\n\n\n\n\nAPI Endpoints\n\n\nLinking and unlinking accounts\n\n\nBefore you can do any bookings, you will need to provide the relevant authentication details to the server.\n\n\nIf the user has an account (as per the \nuserToken\n header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.\n\n\n\n\nauth/{region}?mode={mode}\n: Endpoint to get the available providers for a specific region, with the information to signin/logout if a \nuserToken\n is provided in the headers. If \nmode\n is provided, only information for that mode is returned.\n\n\nauth/{provider}/signin\n: Endpoint to link an account for the specified provider.\n\n\nauth/{provider}/logout\n: Endpoint to unlink an account for the specified provider.\n\n\n\n\nAuth Flow\n\n\nThis flow will depend on the TSP and can be started in two separate ways:\n\n\n\n\nWhen \nlinking accounts\n to a user.\n\n\nWhen doing a \nbooking\n for that particular TSP and the user has no account already linked.\n\n\n\n\nThis flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.\n\n\nFor a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including \nclientId\n, \nclientSecret\n, \nscope\n, \nauthUrl\n, \ntokenUrl\n; and also the required field to be POSTed, including \naccessToken\n, \nrefreshToken\n and \nexpiration\n.\n\n\nFor a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for \nForm-based Booking Flow\n.\n\n\nThe end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of \nForm-based Booking Flow\n.\n\n\n\n\nGetting available TSP for a trip\n\n\nIf there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.\n\n\nThe booking object in the segment may include:\n\n\n\n\na \nquickBookingUrl\n, indicating that the quick booking flow is available.\n\n\na \nbookingUrl\n, indicating that the form-based booking flow is available.\n\n\n\n\n\n\nBooking a segment\n\n\nTo book a segment, either use the \nForm-based Booking Flow\n with the \nbookingURL\n either directly from the segment reference, or the \nQuick Booking Flow\n from the data returned after hitting \nquickBookingUrl\n.\n\n\nForm-based Booking Flow\n\n\nIf form-based booking flow is available for a segment, the \nbookingUrl\n will return a \nBooking Form\n object with instructions to start the booking flow.\n\nA form-based booking flow will possible include the following steps:\n\n\n1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start \nAuth flow\n,\n4) attempt to do the booking and return the Status Form.\n\n\nQuick Booking Flow\n\n\nGetting available TSP products for a trip\n\n\nIf quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. \n\n\nAs part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:\n\n\n\n\ntripUpdateURL\n: A URL for fetching the trip, updated for this TSP product.\n\n\nbookingURL\n: A URL for initiating the booking flow for this TSP product (step 2 of \nform-based booking flow\n)\n\n\ntitle\n\n\nsubtitle\n\n\nbookingTitle\n\n\npriceString\n\n\nprice\n\n\nUSDPrice\n\n\nsurgeString\n\n\nsurgeImageURL\n\n\nETA\n\n\nimageURL\n\n\n\n\n\n\nUpdating trip with booking details\n\n\nAt the end of the booking flow, you will get a \nrefreshURLForSourceObject\n. Hit this URL with a GET request, to get the updated trip.\n\n\nNote that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.\n\n\nTrips with a confirmed booking will also have extra information about the confirmed booking in a field called \nconfirmation\n in the \nbooking\n field of the segment.\n\n\nThis \nconfirmation\n object may include detailed information about the \nprovider\n, \nvehicle\n and \nstatus\n for the booking, with the following possible fields:\n\n\n\n\na \ntitle\n\n\na \nsubtitle\n\n\na \nvalueUrl\n\n\na \nvalue\n\n\n\n\nAnd also a list of possible actions depending on the status of the booking, with the following fields:\n\n\n\n\na \ntitle\n\n\na boolean \nisDestructive\n, indicating whether this action will cancel the booking.\n\n\na \ninternalUrl\n indicating the action of the url is a call to the same server and will return a \nbookingForm\n.\n\n\na \nexternalUrl\n indicating that the action must be handled by the app accordingly.\n\n\n\n\nExamples of actions with \ninternalUrl\n fields are \ncancel booking\n, which will have the \nisDestructive\n field in true, and \nrate booking\n.\n\n\nExamples of actions with \nexternalUrl\n fields are \nqrcode\n values, for showing a ticket to the user, and phone numbers, starting with \ntel:\n.\n\n\n\n\nRating and Tipping\n\n\nWhenever available, the confirmation information will include the \nrate booking\n action, which will include an \ninternalUrl\n which will return a \nbookingForm\n with the following fields:\n\n\n\n\nrate\n, an int value with min and max accepted values.\n\n\nfeedback\n, a string to send an appropriate msg.\n\n\ntip\n, an int value indicating the amount to be paid as tip, in local currency.\n\n\n\n\nThe booking form will include the action url to POST the data.\n\n\n\n\nBooking Form Specs\n\n\nBoth the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.\n\n\nThere exists three different forms:\n\n\n\n\nBooking Form\n\n\nAuth Form\n\n\nStatus Form\n\n\n\n\nAll three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.\n\n\nA Booking Form may include:\n\n\n\n\na title\n\n\na subtitle\n\n\na value\n\n\na \nBookingAction\n, which may include:\n\n\na \nURL\n, to go to the next step in the flow\n\n\na \ntitle\n\n\na \nhudText\n, with a human readable string describing the action (meant to be shown while waiting the response from the backend)\n\n\na boolean \nfinalStep\n, meaning that the next step is the one that will actually do the booking.\n\n\na boolean \ndone\n, indicating that there are no more steps in the flow.\n\n\n\n\n\n\na list of \nFormGroups\n.\n\n\n\n\nA \nFormGroup\n is a lisf of \nFormFields\n with a title and an optional footer.\nA \nFormField\n is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:\n\n\n\n\na (unique) \nid\n, to identify the field\n\n\na \ntitle\n\n\na \nsubtitle\n\n\na \nsidetitle\n\n\na \nvalue\n, that will depend on the FormField type\n\n\na boolean \nrequired\n, indicating that this is a required field to be POSTed,\n\n\na boolean \nreadOnly\n, indicating that this is information to be shown to the user but can not be edited.\n\n\na boolean \nhidden\n, indicating that this field should NOT be shown to the user.\n\n\n\n\nThere are several types of FormFields:\n\n\n\n\nstring\n, which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}\n\n\ntext\n, for long non-editable strings\n\n\nswitch\n, for boolean values\n\n\noption\n, for a list of values, will include the list and the default value\n\n\naddress\n, for locations, value with the following format {lat, lng, address, name}\n\n\ndatetime\n, including the time value in long and an extra field with the timezone id \n\n\nstepper\n, for int values, with extra max and min values\n\n\ntime\n, for seconds since midnight\n\n\npassword\n\n\nlink\n, for urls, with an extra field called \nmethod\n with the following possible values:\n\n\nrefresh\n meaning that this url will return the same step form,\n\n\npost\n meaning that the backend expects a POST on that url,\n\n\n\n\nexternal\n meaning that this will go to an external site, so, no BookingForm will be returned.\n\n\n\n\n\n\nbookingForm\n, this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.\n\n\n\n\n\n\n\n\nBookings in the TripKit SDKs\n\n\nThe TripKit SDKs implement support for bookings:\n\n\n\n\nBookings in TripKit Android (coming soon)\n\n\nBookings in TripKit iOS",
            "title": "Bookings (API)"
        },
        {
            "location": "/enterprise/bookings-api/#overview",
            "text": "Note: Enterprise customers-only  Note: Beta-only  The TripGo API allows making bookings for a handful of transport service providers (TSPs).  This enables your users to:   Link their TSP accounts and keep credentials either stored on the client or server-side.  Get a list of available TSP products for a trip.  Book a specific TSP product for a single segment.  Update the trip with the details of the booked TSP product.  Update the trip with real-time data specific to that booking.   Coming soon:   Book a complete trip consisting of multiple products from multiple TSPs.   In order to enable bookings for your TripGo API key, please  get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.",
            "title": "Overview"
        },
        {
            "location": "/enterprise/bookings-api/#api-endpoints",
            "text": "",
            "title": "API Endpoints"
        },
        {
            "location": "/enterprise/bookings-api/#linking-and-unlinking-accounts",
            "text": "Before you can do any bookings, you will need to provide the relevant authentication details to the server.  If the user has an account (as per the  userToken  header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet.   auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a  userToken  is provided in the headers. If  mode  is provided, only information for that mode is returned.  auth/{provider}/signin : Endpoint to link an account for the specified provider.  auth/{provider}/logout : Endpoint to unlink an account for the specified provider.",
            "title": "Linking and unlinking accounts"
        },
        {
            "location": "/enterprise/bookings-api/#auth-flow",
            "text": "This flow will depend on the TSP and can be started in two separate ways:   When  linking accounts  to a user.  When doing a  booking  for that particular TSP and the user has no account already linked.   This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow.  For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including  clientId ,  clientSecret ,  scope ,  authUrl ,  tokenUrl ; and also the required field to be POSTed, including  accessToken ,  refreshToken  and  expiration .  For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for  Form-based Booking Flow .  The end of this flow will depending on how it was started.\nIf was started to link an account, the flow will end with an empty 204 response, when successfuly linked.\nIf it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of  Form-based Booking Flow .",
            "title": "Auth Flow"
        },
        {
            "location": "/enterprise/bookings-api/#getting-available-tsp-for-a-trip",
            "text": "If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment.  The booking object in the segment may include:   a  quickBookingUrl , indicating that the quick booking flow is available.  a  bookingUrl , indicating that the form-based booking flow is available.",
            "title": "Getting available TSP for a trip"
        },
        {
            "location": "/enterprise/bookings-api/#booking-a-segment",
            "text": "To book a segment, either use the  Form-based Booking Flow  with the  bookingURL  either directly from the segment reference, or the  Quick Booking Flow  from the data returned after hitting  quickBookingUrl .",
            "title": "Booking a segment"
        },
        {
            "location": "/enterprise/bookings-api/#form-based-booking-flow",
            "text": "If form-based booking flow is available for a segment, the  bookingUrl  will return a  Booking Form  object with instructions to start the booking flow. \nA form-based booking flow will possible include the following steps:  1) return the available TSP products to allow the user choose one of them, \n2) check whether we have user credentials to do the booking, if it does, skip 3,\n3) start  Auth flow ,\n4) attempt to do the booking and return the Status Form.",
            "title": "Form-based Booking Flow"
        },
        {
            "location": "/enterprise/bookings-api/#quick-booking-flow",
            "text": "Getting available TSP products for a trip  If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details.   As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come:   tripUpdateURL : A URL for fetching the trip, updated for this TSP product.  bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of  form-based booking flow )  title  subtitle  bookingTitle  priceString  price  USDPrice  surgeString  surgeImageURL  ETA  imageURL",
            "title": "Quick Booking Flow"
        },
        {
            "location": "/enterprise/bookings-api/#updating-trip-with-booking-details",
            "text": "At the end of the booking flow, you will get a  refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip.  Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking.  Trips with a confirmed booking will also have extra information about the confirmed booking in a field called  confirmation  in the  booking  field of the segment.  This  confirmation  object may include detailed information about the  provider ,  vehicle  and  status  for the booking, with the following possible fields:   a  title  a  subtitle  a  valueUrl  a  value   And also a list of possible actions depending on the status of the booking, with the following fields:   a  title  a boolean  isDestructive , indicating whether this action will cancel the booking.  a  internalUrl  indicating the action of the url is a call to the same server and will return a  bookingForm .  a  externalUrl  indicating that the action must be handled by the app accordingly.   Examples of actions with  internalUrl  fields are  cancel booking , which will have the  isDestructive  field in true, and  rate booking .  Examples of actions with  externalUrl  fields are  qrcode  values, for showing a ticket to the user, and phone numbers, starting with  tel: .",
            "title": "Updating trip with booking details"
        },
        {
            "location": "/enterprise/bookings-api/#rating-and-tipping",
            "text": "Whenever available, the confirmation information will include the  rate booking  action, which will include an  internalUrl  which will return a  bookingForm  with the following fields:   rate , an int value with min and max accepted values.  feedback , a string to send an appropriate msg.  tip , an int value indicating the amount to be paid as tip, in local currency.   The booking form will include the action url to POST the data.",
            "title": "Rating and Tipping"
        },
        {
            "location": "/enterprise/bookings-api/#booking-form-specs",
            "text": "Both the booking flow and the auth flow use an ad-hoc format to handle the communication of data between the backend and the apps.  There exists three different forms:   Booking Form  Auth Form  Status Form   All three share the same structure, while Auth and Status are specialized versions of the Booking Form with some extra data.  A Booking Form may include:   a title  a subtitle  a value  a  BookingAction , which may include:  a  URL , to go to the next step in the flow  a  title  a  hudText , with a human readable string describing the action (meant to be shown while waiting the response from the backend)  a boolean  finalStep , meaning that the next step is the one that will actually do the booking.  a boolean  done , indicating that there are no more steps in the flow.    a list of  FormGroups .   A  FormGroup  is a lisf of  FormFields  with a title and an optional footer.\nA  FormField  is a structure that represents the data, either to show to the user or required in the backend for the next step. Each FormField will include:   a (unique)  id , to identify the field  a  title  a  subtitle  a  sidetitle  a  value , that will depend on the FormField type  a boolean  required , indicating that this is a required field to be POSTed,  a boolean  readOnly , indicating that this is information to be shown to the user but can not be edited.  a boolean  hidden , indicating that this field should NOT be shown to the user.   There are several types of FormFields:   string , which adds the following values: placeHolder and KeyboardType {TEXT, EMAIL, PHONE, NUMBER}  text , for long non-editable strings  switch , for boolean values  option , for a list of values, will include the list and the default value  address , for locations, value with the following format {lat, lng, address, name}  datetime , including the time value in long and an extra field with the timezone id   stepper , for int values, with extra max and min values  time , for seconds since midnight  password  link , for urls, with an extra field called  method  with the following possible values:  refresh  meaning that this url will return the same step form,  post  meaning that the backend expects a POST on that url,   external  meaning that this will go to an external site, so, no BookingForm will be returned.    bookingForm , this recursive case is used for showing multiple options, to show one item and allowing to navigate to the details without an extra backend request.\nFor example, it is possible that one bookingForm will include a list of BookingForms, one for each alternative TSP product. The idea is that the user can select one alternative and the app will show this nested BookingForm, which will have a BookingAction for the app to use, in order to continue the booking for that particular TSP product.",
            "title": "Booking Form Specs"
        },
        {
            "location": "/enterprise/bookings-api/#bookings-in-the-tripkit-sdks",
            "text": "The TripKit SDKs implement support for bookings:   Bookings in TripKit Android (coming soon)  Bookings in TripKit iOS",
            "title": "Bookings in the TripKit SDKs"
        },
        {
            "location": "/enterprise/bookings-ios/",
            "text": "Bookings in TripKit iOS\n\n\nNote: Enterprise customers-only\n\n\nNote: Beta-only\n\n\nTripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.\n\n\nPreparations\n\n\nTo get started, configured your project as follows:\n\n\n\n\nInclude \nBookingKit\n from \nshared-ios\n, including all its dependencies.\n\n\nInclude \ntripkit-ios\n as a dependency, including its \nBookings\n add-on.\n\n\nAdd the \nOAuthCallbackURL\n to your \nConfig.plist\n configuration file.\n\n\nMake sure your app has the URL scheme from that callback URL registered.\n\n\n\n\nNext, you need to respond to calls to that \nOAuthCallbackURL\n in your application delegate by implementing \napplication(openURL:options)\n (or its deprecated precursors), and handling the calls similar to this:\n\n\nlet OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}\n\n\n\n\n\n\nLinking and unlinking accounts\n\n\nYou can then which accounts are available for linking for a given region:\n\n\nlet region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}\n\n\n\n\nThis both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account, \nand\n they have not expired.\n\n\nTo kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on \nRxSwift\n:\n\n\nregion.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n\n\n\n\nNote that this helper requires the \nactionURL\n as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified \nmode\n:\n\n\nThese credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the \nregion.linkedAccounts()\n helper above.\n\n\nFor unlinking an account again there's another helper:\n\n\nregion.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}\n\n\n\n\nNote that the helper for unlinking, only requires the \nactionURL\n when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.\n\n\n\n\nGetting available TSP products for a trip\n\n\nAvailable TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.\n\n\nWhether such TSP products are available, is indicated by the segment having a \nbookingQuickInternalURL\n. If that URL exists, the \nTKQuickBookingHelper\n can then fetch all the available products:\n\n\nTKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}\n\n\n\n\nNote\n: Fetching this information does typically not require the user to have linked their account with the TSP of that segment.\n\n\nEach of these come with a variety of information about the product, possibly including information on the price or ETA.\n\n\nThe two main actions that you can take with these details are:\n\n\n\n\nUpdate the trip with the product, using the \ntripUpdateURL\n (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.\n\n\nBook the product, the using \nbookingURL\n (see below for details).\n\n\n\n\n\n\nBooking a segment\n\n\nUsers can book trip on a segment-by-segment basis. The booking requires the \nbookingURL\n for the specific product that the user wants to book as mentioned in the previous section.\n\n\nTripKit iOS has a helper method \nBPKOperator.makeBookingToURL/2\n which then initiates the booking:\n\n\nlet mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}\n\n\n\n\nThis method does a handful of things:\n\n\n\n\nIt checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the \nmode\n parameter).\n\n\nIf the user's account has not been linked, the \nBPKOperator\n will start the OAuth process described \nin the section on linking accounts\n.\n\n\nIf the user's account has already been linked, those credentials will be used.\n\n\nIf there's an error during this process, then observable aborts with an error.\n\n\n\n\n\n\nAn attempt to make the booking is performed, which can have the following outcomes:\n\n\nThe booking was successful and \nBookingResult.UpdateTrip\n is returned with a URL to update the trip, which will then include the confirmation details.\n\n\nThe booking can be made, but more information is required by the user. This is the case \nBookingResult.LoadTrip\n which returns a booking form, which can be then be displayed using the \nBPKBookingViewController\n.\n\n\nThe booking can be made, but the user first need to accept an agreement. This is the case \n`BookingResult.UpdateTrip\n which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to \nBPKOperator.makeBookingToURL\n again.\n\n\nIf there's an error, the observable aborts with an error.\n\n\n\n\n\n\n\n\n\n\nUpdating trip with booking details / confirmation\n\n\nAs described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.\n\n\nThis process is the same as updating a trip with real-time data, e.g.:\n\n\nlet router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}\n\n\n\n\nNoteworthy is here, the \nsegment.bookingConfirmation\n property provided by \nTKQuickBookingHelper\n which returns a \nTKBookingConfirmation\n struct after a booking has been made. This struct includes:\n\n\n\n\nstatus\n: A title and optional description describing the current status of the trip.\n\n\nInformation on the \nprovider\n and \nvehicle\n servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.\n\n\nA list of actions, such as calling the provider or cancelling the booking.",
            "title": "Bookings (iOS)"
        },
        {
            "location": "/enterprise/bookings-ios/#bookings-in-tripkit-ios",
            "text": "Note: Enterprise customers-only  Note: Beta-only  TripKit iOS supports all the booking API endpoints, including handling the OAuth process. OAuth credentials are stored securely in the device's keychain and, optionally, linked to the user's account.",
            "title": "Bookings in TripKit iOS"
        },
        {
            "location": "/enterprise/bookings-ios/#preparations",
            "text": "To get started, configured your project as follows:   Include  BookingKit  from  shared-ios , including all its dependencies.  Include  tripkit-ios  as a dependency, including its  Bookings  add-on.  Add the  OAuthCallbackURL  to your  Config.plist  configuration file.  Make sure your app has the URL scheme from that callback URL registered.   Next, you need to respond to calls to that  OAuthCallbackURL  in your application delegate by implementing  application(openURL:options)  (or its deprecated precursors), and handling the calls similar to this:  let OAuthCallbackURL = SGKConfig.sharedIntance().oauthCallbackURL()\nif (URL.absoluteString.hasPrefix(OAuthCallbackURL.absoluteString)) {\n  OAuthSwift.handleOpenURL(URL)\n  return true\n}",
            "title": "Preparations"
        },
        {
            "location": "/enterprise/bookings-ios/#linking-and-unlinking-accounts",
            "text": "You can then which accounts are available for linking for a given region:  let region = SVKRegionManager.sharedInstance().regionWithName(...)\nregion.linkedAccounts() { auths in\n  for auth in auths {\n    if auth.isConnected {\n      // Update UI and allow unlinking\n    } else {\n      // Update UI and allow linking\n    }\n  }\n}  This both checks which modes can be associated with an account, and also whether the credentials are already available. Credentials are available when they are either stored locally or associated with the user's account,  and  they have not expired.  To kick of linking, which saves the credentials locally and to the user's account (if the user is logged in), there's a helper based on  RxSwift :  region.rx_linkAccount(mode, remoteURL: auth.actionURL)\n  .subscribe { event in\n    switch event {\n    case .Next(let success):\n      // Account has been linked. Update the UI.\n    case .Error(let error):\n      // Account could not get linked. Handle error.\n      print(error)\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)  Note that this helper requires the  actionURL  as this is used to fetch what information is necessary for the OAuth flow for the provider servicing the specified  mode :  These credentials will then be used automatically later on when bookings are made. To check, whether credentials are currently stored and still valid (they can expire), you can use the  region.linkedAccounts()  helper above.  For unlinking an account again there's another helper:  region.unlinkAccount(mode, remoteURL: auth.actionURL) { success in\n  // Do something\n}  Note that the helper for unlinking, only requires the  actionURL  when the OAuth credentials have been associated with the user's account. Unlinking removes credentials stored locally and those associated with the user's account.",
            "title": "Linking and unlinking accounts"
        },
        {
            "location": "/enterprise/bookings-ios/#getting-available-tsp-products-for-a-trip",
            "text": "Available TSP products for a trip are associated with a segment. The information about these products is not included in the standard routing responses, but needs to be fetched separately.  Whether such TSP products are available, is indicated by the segment having a  bookingQuickInternalURL . If that URL exists, the  TKQuickBookingHelper  can then fetch all the available products:  TKQuickBookingHelper.fetchQuickBookings(forSegment: segment) { quickBookings in\n  // Update UI\n}  Note : Fetching this information does typically not require the user to have linked their account with the TSP of that segment.  Each of these come with a variety of information about the product, possibly including information on the price or ETA.  The two main actions that you can take with these details are:   Update the trip with the product, using the  tripUpdateURL  (see below for details). This is useful if you need the trip's properties to reflect the price and ETA of the selected product.  Book the product, the using  bookingURL  (see below for details).",
            "title": "Getting available TSP products for a trip"
        },
        {
            "location": "/enterprise/bookings-ios/#booking-a-segment",
            "text": "Users can book trip on a segment-by-segment basis. The booking requires the  bookingURL  for the specific product that the user wants to book as mentioned in the previous section.  TripKit iOS has a helper method  BPKOperator.makeBookingToURL/2  which then initiates the booking:  let mode = segment.modeIdentifier()\nBPKOperator.makeBookingToURL(mode, URL: bookingURL)\n  .subscribe { event in\n    switch event {\n    case .Next(.UpdateTrip(let url)):\n      // Booking went through. Update the trip (see below).\n    case .Next(.LoadForm(let form)):\n      // More information required.\n      // Display booking form using `BPKBookingViewController`\n    case .Next(.ShowAgreement(let displayUrl, let discardUrl))\n      // User confirmation required.\n    case .Error(let error):\n      // Handle error\n    case .Completed:\n      break // Nothing to do\n    }\n  }\n  .addDisposableTo(disposeBag)\n}  This method does a handful of things:   It checks whether the user has already linked their account for the provider of the segment (the credentials are linked to the segment's mode, which is why the method takes the  mode  parameter).  If the user's account has not been linked, the  BPKOperator  will start the OAuth process described  in the section on linking accounts .  If the user's account has already been linked, those credentials will be used.  If there's an error during this process, then observable aborts with an error.    An attempt to make the booking is performed, which can have the following outcomes:  The booking was successful and  BookingResult.UpdateTrip  is returned with a URL to update the trip, which will then include the confirmation details.  The booking can be made, but more information is required by the user. This is the case  BookingResult.LoadTrip  which returns a booking form, which can be then be displayed using the  BPKBookingViewController .  The booking can be made, but the user first need to accept an agreement. This is the case  `BookingResult.UpdateTrip  which returns two URLs. The first URL should be displayed to the user, and the user has accepted the terms once the user gets to the second URL. If the user accepted, you should then kick off the initial call to  BPKOperator.makeBookingToURL  again.  If there's an error, the observable aborts with an error.",
            "title": "Booking a segment"
        },
        {
            "location": "/enterprise/bookings-ios/#updating-trip-with-booking-details-confirmation",
            "text": "As described above, the booking process provides URLs to fetch an update of the trip. This can be used to update a trip with a selected TSP process, and also to fetch the booking status of a trip.  This process is the same as updating a trip with real-time data, e.g.:  let router = TKBuzzRouter()\nlet context = TKTripKit.sharedInstance().tripKitContext\nrouter.downloadTrip(url, intoTripKitContext: context) { updatedTrip in\n  if let updatedTrip = updatedTrip {\n    let request = originalTrip.request\n    originalTrip.removeFromRequest()\n    updatedTrip.moveToRequest(request, markAsPreferred: true)\n  }\n}  Noteworthy is here, the  segment.bookingConfirmation  property provided by  TKQuickBookingHelper  which returns a  TKBookingConfirmation  struct after a booking has been made. This struct includes:   status : A title and optional description describing the current status of the trip.  Information on the  provider  and  vehicle  servicing this booking. Note that these can be missing; typically while the booking is still being processed by the TSP, in the cast that it has been cancelled, or also after the trip has been completed.  A list of actions, such as calling the provider or cancelling the booking.",
            "title": "Updating trip with booking details / confirmation"
        }
    ]
}